import MediaChromeElement from './media-chrome-element.js';

<<<<<<< HEAD
/*
  <media-thumbnail-preview player="" url="" time="0.00">
*/
=======
// <media-thumbnail-preview player="" url="" time="0.00">
>>>>>>> fa09d02d38daa21148a0e8e9146fca517f2e3a86
const template = document.createElement('template');

template.innerHTML = `
  <style>
    :host {
      box-sizing: border-box;
      background-color: #000;
      width: 284px;
      height: 160px;
<<<<<<< HEAD
      overflow: hidden;
    }

    img {
      position: absolute;
      left: 0;
      top: 0;
    }
  </style>
  <img crossorigin loading="eager" decoding="async" />
=======
    }
  </style>
>>>>>>> fa09d02d38daa21148a0e8e9146fca517f2e3a86
`;

class MediaThumbnailPreviewElement extends MediaChromeElement {
  static get observedAttributes() {
<<<<<<< HEAD
    return ['time'].concat(super.observedAttributes || []);
=======
    return ['url', 'time'].concat(super.observedAttributes || []);
>>>>>>> fa09d02d38daa21148a0e8e9146fca517f2e3a86
  }

  constructor() {
    super();

    const shadow = this.attachShadow({ mode: 'open' });
    this.shadowRoot.appendChild(template.content.cloneNode(true));
  }

<<<<<<< HEAD
  set time(time) {
=======
  set url(url) {
    const setImageURL = async (url) => {
      const response = await fetch(url, {});
      const data = await response.json();
      const urlObj = new URL(url);
      const thumbnailDir = urlObj.href.substr(0, urlObj.href.lastIndexOf('/')) + '/';

      console.log(data);
      this.data = data;
      this.style.backgroundImage = `url(${thumbnailDir}${data.url})`;
    };

    if (url) {
      setImageURL(url);
    }
  }

  get url() {
    return this.getAttribute('url');
  }

  set time(time) {
    // Hack to get this working, but need full URLs in the storyboard vtt
    let baseURL = 'http://image.mux.com/DS00Spx1CV902MCtPj5WknGlR102V5HFkDe/';

    console.log('here', this.media)
>>>>>>> fa09d02d38daa21148a0e8e9146fca517f2e3a86
    if (this.media && this.media.textTracks && this.media.textTracks.length > 0) {
      let track = Array.prototype.find.call(this.media.textTracks, (t)=>{
        return t.label == 'thumbnails';
      });

<<<<<<< HEAD
      if (!track) return;

      let cue = Array.prototype.find.call(track.cues, c => c.startTime >= time);

      if (cue) {
        const url = new URL(cue.text);
        const [x,y,w,h] = url.hash.split('=')[1].split(',');
        const img = this.shadowRoot.querySelector('img');
        const src = url.origin + url.pathname;
        const scale = this.offsetWidth / w;

        const resize = () => {
          img.style.width = `${scale * img.naturalWidth}px`;
          img.style.height = `${scale * img.naturalHeight}px`;
        };

        if (img.src !== src) {
          img.onload = resize;
          img.src = src;
          resize();
        }

        resize();
        img.style.left = `-${scale * x}px`;
        img.style.top = `-${scale * y}px`;
        // this.style.backgroundImage = `url(${url.origin + url.pathname})`;
        // this.style.backgroundPosition = `left ${x}px top ${y}px`;
=======
      console.log(track);

      if (!track) return;
      console.log(track.cues);

      let cue = Array.prototype.find.call(track.cues, c => time >= c.startTime);

      if (cue) {
        const url = new URL(cue.text, baseURL);
        console.log(url);

        // this.style.backgroundImage = `url(${baseURL}${cue.text})`;
        // this.style.backgroundPosition = `left ${tile.x}px top ${tile.y}px`;
>>>>>>> fa09d02d38daa21148a0e8e9146fca517f2e3a86
      }
    }
  }

  get time() {
    return parseFloat(this.getAttribute('time'));
  }

  mediaSetCallback(media){
<<<<<<< HEAD
    const trackList = media && media.textTracks;

    if (!trackList || !trackList.addEventListener) return;

    // Create a bound, removeable function for track changes
    this._trackChangeHandler = (evt) => {
      for (let i = 0; i < trackList.length; i++) {
        let track = trackList[i];
        if (track.label === 'thumbnails') {
          // Prime the image when a track is added
          if (!this.time) this.time = 0;
        }
      }
    };

    trackList.addEventListener('addtrack', this._trackChangeHandler, false);
    this._trackChangeHandler();
  }

  mediaUnsetCallback(media) {
    const trackList = media && media.textTracks;

    if (trackList && trackList.removeEventListener) {
      trackList.removeEventListener('addtrack', this._trackChangeHandler);
    }
  }

  // set url(url) {
  //   const setImageURL = async (url) => {
  //     const response = await fetch(url, {});
  //     const data = await response.json();
  //     const urlObj = new URL(url);
  //     const thumbnailDir = urlObj.href.substr(0, urlObj.href.lastIndexOf('/')) + '/';
  //
  //     console.log(data);
  //     this.data = data;
  //     this.style.backgroundImage = `url(${thumbnailDir}${data.url})`;
  //   };
  //
  //   if (url) {
  //     setImageURL(url);
  //   }
  // }
  //
  // get url() {
  //   return this.getAttribute('url');
  // }
=======
    console.log('mediaSet');
  }
>>>>>>> fa09d02d38daa21148a0e8e9146fca517f2e3a86
}

if (!window.customElements.get('media-thumbnail-preview')) {
  window.customElements.define('media-thumbnail-preview', MediaThumbnailPreviewElement);
  window.MediaThumbnailPreviewElement = MediaThumbnailPreviewElement;
}

export default MediaThumbnailPreviewElement;
